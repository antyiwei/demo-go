The Go path is used to resolve import statements.It is implemented by and documented in the go/build package.The GOPATH environment variable lists places to look for Go code.On Unix, the value is a colon-separated string.On Windows, the value is a semicolon-separated string.On Plan 9, the value is a list.If the environment variable is unset, GOPATH defaultsto a subdirectory named "go" in the user's home directory($HOME/go on Unix, %USERPROFILE%\go on Windows),unless that directory holds a Go distribution.Run "go env GOPATH" to see the current GOPATH.See https://golang.org/wiki/SettingGOPATH to set a custom GOPATH.Each directory listed in GOPATH must have a prescribed structure:The src directory holds source code. The path below srcdetermines the import path or executable name.The pkg directory holds installed package objects.As in the Go tree, each target operating system andarchitecture pair has its own subdirectory of pkg(pkg/GOOS_GOARCH).If DIR is a directory listed in the GOPATH, a package withsource in DIR/src/foo/bar can be imported as "foo/bar" andhas its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".The bin directory holds compiled commands.Each command is named for its source directory, but onlythe final element, not the entire path. That is, thecommand with source in DIR/src/foo/quux is installed intoDIR/bin/quux, not DIR/bin/foo/quux. The "foo/" prefix is strippedso that you can add DIR/bin to your PATH to get at theinstalled commands. If the GOBIN environment variable isset, commands are installed to the directory it names insteadof DIR/bin. GOBIN must be an absolute path.Here's an example directory layout:    GOPATH=/home/user/go    /home/user/go/        src/            foo/                bar/               (go code in package bar)                    x.go                quux/              (go code in package main)                    y.go        bin/            quux                   (installed command)        pkg/            linux_amd64/                foo/                    bar.a          (installed package object)Go searches each directory listed in GOPATH to find source code,but new packages are always downloaded into the first directoryin the list.See https://golang.org/doc/code.html for an example.Internal DirectoriesCode in or below a directory named "internal" is importable onlyby code in the directory tree rooted at the parent of "internal".Here's an extended version of the directory layout above:    /home/user/go/        src/            crash/                bang/              (go code in package bang)                    b.go            foo/                   (go code in package foo)                f.go                bar/               (go code in package bar)                    x.go                internal/                    baz/           (go code in package baz)                        z.go                quux/              (go code in package main)                    y.goThe code in z.go is imported as "foo/internal/baz", but thatimport statement can only appear in source files in the subtreerooted at foo. The source files foo/f.go, foo/bar/x.go, andfoo/quux/y.go can all import "foo/internal/baz", but the source filecrash/bang/b.go cannot.See https://golang.org/s/go14internal for details.Vendor DirectoriesGo 1.6 includes support for using local copies of external dependenciesto satisfy imports of those dependencies, often referred to as vendoring.Code below a directory named "vendor" is importable onlyby code in the directory tree rooted at the parent of "vendor",and only using an import path that omits the prefix up to andincluding the vendor element.Here's the example from the previous section,but with the "internal" directory renamed to "vendor"and a new foo/vendor/crash/bang directory added:    /home/user/go/        src/            crash/                bang/              (go code in package bang)                    b.go            foo/                   (go code in package foo)                f.go                bar/               (go code in package bar)                    x.go                vendor/                    crash/                        bang/      (go code in package bang)                            b.go                    baz/           (go code in package baz)                        z.go                quux/              (go code in package main)                    y.goThe same visibility rules apply as for internal, but the codein z.go is imported as "baz", not as "foo/vendor/baz".Code in vendor directories deeper in the source tree shadowscode in higher directories. Within the subtree rooted at foo, an importof "crash/bang" resolves to "foo/vendor/crash/bang", not thetop-level "crash/bang".Code in vendor directories is not subject to import pathchecking (see 'go help importpath').When 'go get' checks out or updates a git repository, it now alsoupdates submodules.Vendor directories do not affect the placement of new repositoriesbeing checked out for the first time by 'go get': those are alwaysplaced in the main GOPATH, never in a vendor subtree.See https://golang.org/s/go15vendor for details.翻译：Go路径用于解析导入语句。它由go / build软件包实施并记录在案。GOPATH环境变量列出了查找Go代码的位置。在Unix上，该值是冒号分隔的字符串。在Windows上，该值是以分号分隔的字符串。在计划9中，该值是一个列表。如果环境变量未设置，则GOPATH默认到用户主目录中名为“go”的子目录（$ HOME /在Unix上运行，％USERPROFILE％\在Windows上运行），除非该目录拥有Go分配。运行“go env GOPATH”来查看当前的GOPATH。请参阅https://golang.org/wiki/SettingGOPATH以设置自定义GOPATH。GOPATH中列出的每个目录必须具有规定的结构：src目录保存源代码。 src下面的路径确定导入路径或可执行文件的名称。pkg目录保存已安装的软件包对象。和Go树一样，每个目标操作系统和体系结构对具有其自己的pkg子目录（PKG / GOOS_GOARCH）。如果DIR是GOPATH中列出的目录，则为包DIR / src / foo / bar中的源文件可以导入为“foo / bar”和将其编译后的表格安装到“DIR / pkg / GOOS_GOARCH / foo / bar.a”。bin目录保存已编译的命令。每个命令都以其源目录命名，但仅限于该目录最后的因素，而不是整个路径。那就是在DIR / src / foo / quux中的源代码被安装到DIR / bin / quux，而不是DIR / bin / foo / quux。 “foo /”前缀被删除这样你就可以将DIR / bin添加到你的PATH中去安装的命令。如果GOBIN环境变量是设置，命令安装到它所命名的目录的DIR / bin。戈宾必须是绝对路径。以下是一个目录布局示例：    GOPATH=/home/user/go    /home/user/go/        src/            foo/                bar/               (go code in package bar)                    x.go                quux/              (go code in package main)                    y.go        bin/            quux                   (installed command)        pkg/            linux_amd64/                foo/                    bar.a          (installed package object)Go搜索GOPATH中列出的每个目录以查找源代码，但新包总是下载到第一个目录中在列表中。有关示例，请参阅https://golang.org/doc/code.html。内部目录名为“internal”的目录中或以下的代码仅可导入通过植根于“internal”父级的目录树中的代码。以下是上述目录布局的扩展版本：    /home/user/go/        src/            crash/                bang/              (go code in package bang)                    b.go            foo/                   (go code in package foo)                f.go                bar/               (go code in package bar)                    x.go                internal/                    baz/           (go code in package baz)                        z.go                quux/              (go code in package main)                    y.goz.go中的代码被导入为“foo/internal/baz”，但是导入语句只能出现在子树中的源文件中扎根于富。源文件foo/f.go，foo/bar/x.go和foo/quux/y.go都可以导入“foo/internal/baz”，但可以导入源文件crash/bang/b.go不能。详情请参阅https://golang.org/s/go14internal。供应商目录Go 1.6支持使用本地外部依赖关系的副本以满足这些依赖关系的进口，通常被称为售货。名为“vendor”的目录下的代码仅可导入通过植根于“vendor”父级的目录树中的代码，并且只使用一个省略了前缀的导入路径包括供应商元素。这是上一节的示例，但是将“内部”目录重命名为“供应商”并添加了一个新的foo / vendor / crash / bang目录：   /home/user/go/        src/            crash/                bang/              (go code in package bang)                    b.go            foo/                   (go code in package foo)                f.go                bar/               (go code in package bar)                    x.go                vendor/                    crash/                        bang/      (go code in package bang)                            b.go                    baz/           (go code in package baz)                        z.go                quux/              (go code in package main)                    y.go相同的可见性规则适用于内部，但代码在z.go中被导入为“baz”，而不是“foo/vendor/baz”。源代码树阴影中供应商目录中的代码更深代码在更高的目录中。在植根于foo的子树内，是一个导入“崩溃/爆炸”解决为“foo/vendor/crash/bang”，而不是顶级“撞击/爆炸”。供应商目录中的代码不受导入路径的限制检查（参见'go help importpath'）。当'go get'检出或更新git存储库时，现在也是如此更新子模块。供应商目录不会影响新存储库的位置第一次被'去得到'检出：那些总是放置在主GOPATH中，从不放在供应商子树中。详情请参阅https://golang.org/s/go15vendor。